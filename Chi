build/CMakeFiles/CMakeOutput.log: /usr/lib/gcc/x86_64-linux-gnu/5/collect2 -plugin /usr/lib/gcc/x86_64-linux-gnu/5/liblto_plugin.so -plugin-opt=/usr/lib/gcc/x86_64-linux-gnu/5/lto-wrapper -plugin-opt=-fresolution=/tmp/ccuH6KHd.res -plugin-opt=-pass-through=-lgcc_s -plugin-opt=-pass-through=-lgcc -plugin-opt=-pass-through=-lc -plugin-opt=-pass-through=-lgcc_s -plugin-opt=-pass-through=-lgcc --sysroot=/ --build-id --eh-frame-hdr -m elf_x86_64 --hash-style=gnu --as-needed -export-dynamic -dynamic-linker /lib64/ld-linux-x86-64.so.2 -z relro -o cmTC_a85f9 /usr/lib/gcc/x86_64-linux-gnu/5/../../../x86_64-linux-gnu/crt1.o /usr/lib/gcc/x86_64-linux-gnu/5/../../../x86_64-linux-gnu/crti.o /usr/lib/gcc/x86_64-linux-gnu/5/crtbegin.o -L/usr/lib/gcc/x86_64-linux-gnu/5 -L/usr/lib/gcc/x86_64-linux-gnu/5/../../../x86_64-linux-gnu -L/usr/lib/gcc/x86_64-linux-gnu/5/../../../../lib -L/lib/x86_64-linux-gnu -L/lib/../lib -L/usr/lib/x86_64-linux-gnu -L/usr/lib/../lib -L/usr/lib/gcc/x86_64-linux-gnu/5/../../.. CMakeFiles/cmTC_a85f9.dir/CMakeCXXCompilerABI.cpp.o -lstdc++ -lm -lgcc_s -lgcc -lc -lgcc_s -lgcc /usr/lib/gcc/x86_64-linux-gnu/5/crtend.o /usr/lib/gcc/x86_64-linux-gnu/5/../../../x86_64-linux-gnu/crtn.o
build/CMakeFiles/CMakeOutput.log:  link line: [ /usr/lib/gcc/x86_64-linux-gnu/5/collect2 -plugin /usr/lib/gcc/x86_64-linux-gnu/5/liblto_plugin.so -plugin-opt=/usr/lib/gcc/x86_64-linux-gnu/5/lto-wrapper -plugin-opt=-fresolution=/tmp/ccuH6KHd.res -plugin-opt=-pass-through=-lgcc_s -plugin-opt=-pass-through=-lgcc -plugin-opt=-pass-through=-lc -plugin-opt=-pass-through=-lgcc_s -plugin-opt=-pass-through=-lgcc --sysroot=/ --build-id --eh-frame-hdr -m elf_x86_64 --hash-style=gnu --as-needed -export-dynamic -dynamic-linker /lib64/ld-linux-x86-64.so.2 -z relro -o cmTC_a85f9 /usr/lib/gcc/x86_64-linux-gnu/5/../../../x86_64-linux-gnu/crt1.o /usr/lib/gcc/x86_64-linux-gnu/5/../../../x86_64-linux-gnu/crti.o /usr/lib/gcc/x86_64-linux-gnu/5/crtbegin.o -L/usr/lib/gcc/x86_64-linux-gnu/5 -L/usr/lib/gcc/x86_64-linux-gnu/5/../../../x86_64-linux-gnu -L/usr/lib/gcc/x86_64-linux-gnu/5/../../../../lib -L/lib/x86_64-linux-gnu -L/lib/../lib -L/usr/lib/x86_64-linux-gnu -L/usr/lib/../lib -L/usr/lib/gcc/x86_64-linux-gnu/5/../../.. CMakeFiles/cmTC_a85f9.dir/CMakeCXXCompilerABI.cpp.o -lstdc++ -lm -lgcc_s -lgcc -lc -lgcc_s -lgcc /usr/lib/gcc/x86_64-linux-gnu/5/crtend.o /usr/lib/gcc/x86_64-linux-gnu/5/../../../x86_64-linux-gnu/crtn.o]
build/CMakeFiles/CMakeOutput.log:    arg [-plugin-opt=/usr/lib/gcc/x86_64-linux-gnu/5/lto-wrapper] ==> ignore
build/CMakeFiles/CMakeOutput.log:    arg [-plugin-opt=-fresolution=/tmp/ccuH6KHd.res] ==> ignore
build/CMakeFiles/CMakeOutput.log:    arg [-plugin-opt=-pass-through=-lgcc_s] ==> ignore
build/CMakeFiles/CMakeOutput.log:    arg [-plugin-opt=-pass-through=-lgcc] ==> ignore
build/CMakeFiles/CMakeOutput.log:    arg [-plugin-opt=-pass-through=-lc] ==> ignore
build/CMakeFiles/CMakeOutput.log:    arg [-plugin-opt=-pass-through=-lgcc_s] ==> ignore
build/CMakeFiles/CMakeOutput.log:    arg [-plugin-opt=-pass-through=-lgcc] ==> ignore
Binary file build/Distribution/unit_test/CMakeFiles/distribution_test.dir/distribution_test.cpp.o matches
Binary file build/Distribution/unit_test/distribution_test matches
Binary file build/Geometry/unit_test/CMakeFiles/plane_test.dir/plane_test.cpp.o matches
Binary file build/Geometry/unit_test/plane_test matches
Binary file build/MC.exe matches
Binary file build/Material/CMakeFiles/material.dir/Material.cpp.o matches
Binary file build/Material/CMakeFiles/material.dir/Nuclide.cpp.o matches
Binary file build/Material/CMakeFiles/material.dir/Reaction.cpp.o matches
Binary file build/Material/CMakeFiles/material.dir/XSec.cpp.o matches
Binary file build/Material/libmaterial.a matches
Binary file build/Parser/CMakeFiles/parser.dir/XMLparser.cpp.o matches
Binary file build/Parser/libparser.a matches
Binary file build/Particle/unit_test/CMakeFiles/particle_test.dir/particle_test.cpp.o matches
Binary file build/Particle/unit_test/particle_test matches
Binary file build/Simulator/CMakeFiles/simulator.dir/Simulator.cpp.o matches
Binary file build/Simulator/libsimulator.a matches
Binary file build/Simulator/unit_test/CMakeFiles/integral_simulation_test.dir/integral_simulation_test.cpp.o matches
Binary file build/Simulator/unit_test/integral_simulation_test matches
Binary file build/Utilities/CMakeFiles/utils.dir/pugixml.cpp.o matches
Binary file build/Utilities/libutils.a matches
Binary file build/Utilities/unit_test/CMakeFiles/point_test.dir/point_test.cpp.o matches
Binary file build/Utilities/unit_test/CMakeFiles/solver_test.dir/solver_test.cpp.o matches
Binary file build/Utilities/unit_test/point_test matches
Binary file build/Utilities/unit_test/solver_test matches
Binary file build/VReduction/CMakeFiles/vreduction.dir/VReduction.cpp.o matches
Binary file build/VReduction/libvreduction.a matches
Estimator/Estimator.cpp:	{ bin->score( P, grid, told, track ); }
Estimator/Estimator.cpp:			tally_endHistory( bin->tally[j][i] );
Estimator/Estimator.cpp:			tally_stats( bin->tally[j][i], trackTime );
Estimator/Estimator.cpp:		output << "lower(" + bin->unit + ")\tupper(" + bin->unit + ")\t";
Estimator/Estimator.cpp:				output << std::setw(12) << bin->tally[j][i].mean << "\t";
Estimator/Estimator.cpp:			        output << std::setw(12) << bin->tally[j][i].meanUncer << "\t";
Estimator/Estimator.cpp:	{ Pl[n] = ( ( 2.0*n - 1.0 ) * mu * Pl[n-1] - ( n - 1.0 ) * Pl[n-2] ) / n; }
Estimator/Estimator.cpp:	bin->score( P, grid, told, track );
Estimator/Estimator.cpp:			tally_endHistory( bin->tally[j][i] );
Estimator/Estimator.cpp:			tally_stats( bin->tally[j][i], trackTime );
Estimator/Estimator.cpp:		const double B = bin->tally[j][0].meanUncer / bin->tally[j][0].mean;
Estimator/Estimator.cpp:			const double A = bin->tally[j][i].meanUncer / bin->tally[j][i].mean;
Estimator/Estimator.cpp:			bin->tally[j][i].meanUncer = std::sqrt( A*A + B*B );
Estimator/Estimator.cpp:			bin->tally[j][i].mean = bin->tally[j][i].mean / bin->tally[j][0].mean;
Estimator/Estimator.cpp:			bin->tally[j][i].meanUncer = bin->tally[j][i].meanUncer * bin->tally[j][i].mean;
Estimator/Estimator.cpp:			tensor_bin[0][i]->tally[j][0].mean = tensor_bin[0][i]->tally[j][0].mean / bin->tally[j][0].mean;
Estimator/Estimator.cpp:		output << "upper(" + bin->unit + ")\tlower(" + bin->unit + ")\t";
Estimator/Estimator.cpp:			output << "\t" << std::setw(12) << std::left << grid[Nbin-j];
Estimator/Estimator.cpp:		        output << "\t" << std::setw(12) << std::left << grid[Nbin-j-1]; 
Estimator/Estimator.cpp:		        output << "\t" << std::setw(12) << bin->tally[Nbin-j-1][0].mean; 
Estimator/Estimator.cpp:		        output << "\t" << std::setw(12) << bin->tally[Nbin-j-1][0].meanUncer; 
Estimator/Estimator.cpp:		        output << "\t" << std::setw(12) << std::left << Chi[Nbin-j-1].mean;
Estimator/Estimator.cpp:				output << std::setw(12) << bin->tally[Nbin-j-1][i].mean << "\t";
Estimator/Estimator.cpp:			        output << std::setw(12) << bin->tally[Nbin-j-1][i].meanUncer << "\t";
Estimator/Estimator.cpp:					output << std::setw(12) << tensor_bin[n][Nbin-i-1]->tally[Nbin-j-1][0].mean << "\t"; 
Estimator/Estimator.cpp:					output << std::setw(12) << tensor_bin[n][Nbin-i-1]->tally[Nbin-j-1][0].meanUncer << "\t"; 
Utilities/Catch.h:// can be combined, en-mass, with the _NO_ forms later.
Utilities/Catch.h:// see: http://stackoverflow.com/questions/36901803/gettimeofday-not-declared-in-this-scope-cygwin
Utilities/Catch.h:                decomposedExpression->reconstructExpression( reconstructedExpression );
Utilities/Catch.h:        valuesGen->add( value );
Utilities/Catch.h:        valuesGen->add( val1 );
Utilities/Catch.h:        valuesGen->add( val2 );
Utilities/Catch.h:        valuesGen->add( val1 );
Utilities/Catch.h:        valuesGen->add( val2 );
Utilities/Catch.h:        valuesGen->add( val3 );
Utilities/Catch.h:        valuesGen->add( val1 );
Utilities/Catch.h:        valuesGen->add( val2 );
Utilities/Catch.h:        valuesGen->add( val3 );
Utilities/Catch.h:        valuesGen->add( val4 );
Utilities/Catch.h:            virtual bool matches( TestCaseInfo const& testCase ) const { return !m_underlyingPattern->matches( testCase ); }
Utilities/Catch.h:// can be combined, en-mass, with the _NO_ forms later.
Utilities/Catch.h:        int position; // -1 means non-positional (floating)
Utilities/Catch.h:            // Bind a non-boolean data member (requires placeholder string)
Utilities/Catch.h:            // Bind a method taking a single, non-boolean argument (requires a placeholder string)
Utilities/Catch.h:                        errors.push_back( std::string( ex.what() ) + "\n- while parsing: (" + arg.commands() + ")" );
Utilities/Catch.h:                                                        .setWidth( CATCH_CONFIG_CONSOLE_WIDTH - maxNameLen-8 ) );
Utilities/Catch.h:            assert( m_parent ); // Should always be non-null except for root
Utilities/Catch.h:                section->tryOpen();
Utilities/Catch.h:            m_deepestSection->stdOut = testCaseStats.stdOut;
Utilities/Catch.h:            m_deepestSection->stdErr = testCaseStats.stdErr;
Utilities/Catch.h:                            // see http://stackoverflow.com/questions/404107/why-are-control-characters-illegal-in-xml-1-0
Utilities/Random.cpp://   - To mix these C routines with Fortran-90 compiled
Utilities/Random.cpp:             " <64 bits in long-int, can-t generate RN-s\n");
Utilities/pugixml.cpp:#	pragma warning(disable: 4611) // interaction between '_setjmp' and C++ object destruction is non-portable
Utilities/pugixml.cpp:		if (n->header & impl::xml_memory_page_name_allocated_mask)
Utilities/pugixml.cpp:			alloc.deallocate_string(n->name);
Utilities/pugixml.cpp:		if (n->header & impl::xml_memory_page_value_allocated_mask)
Utilities/pugixml.cpp:			alloc.deallocate_string(n->value);
Utilities/pugixml.cpp:		for (xml_attribute_struct* attr = n->first_attribute; attr; )
Utilities/pugixml.cpp:		for (xml_node_struct* child = n->first_child; child; )
Utilities/pugixml.cpp:		// check if we have a non-empty XML declaration
Utilities/pugixml.cpp:		// only endian-swapping is required
Utilities/pugixml.cpp:		// only endian-swapping is required
Utilities/pugixml.cpp:		// there are four non-leading characters at the end, sequence tail is broken so might as well process the whole chunk
Utilities/pugixml.cpp:		node_copy_string(dn->name, dn->header, xml_memory_page_name_allocated_mask, sn->name, sn->header, shared_alloc);
Utilities/pugixml.cpp:		node_copy_string(dn->value, dn->header, xml_memory_page_value_allocated_mask, sn->value, sn->header, shared_alloc);
Utilities/pugixml.cpp:		for (xml_attribute_struct* sa = sn->first_attribute; sa; sa = sa->next_attribute)
Utilities/pugixml.cpp:		xml_node_struct* sit = sn->first_child;
Utilities/pugixml.cpp:		return dn ? impl::strcpy_insitu(dn->value, dn->header, impl::xml_memory_page_value_allocated_mask, rhs, impl::strlength(rhs)) : false;
Utilities/pugixml.cpp:		return dn ? impl::set_value_integer<unsigned int>(dn->value, dn->header, impl::xml_memory_page_value_allocated_mask, rhs, rhs < 0) : false;
Utilities/pugixml.cpp:		return dn ? impl::set_value_integer<unsigned int>(dn->value, dn->header, impl::xml_memory_page_value_allocated_mask, rhs, false) : false;
Utilities/pugixml.cpp:		return dn ? impl::set_value_integer<unsigned long>(dn->value, dn->header, impl::xml_memory_page_value_allocated_mask, rhs, rhs < 0) : false;
Utilities/pugixml.cpp:		return dn ? impl::set_value_integer<unsigned long>(dn->value, dn->header, impl::xml_memory_page_value_allocated_mask, rhs, false) : false;
Utilities/pugixml.cpp:		return dn ? impl::set_value_convert(dn->value, dn->header, impl::xml_memory_page_value_allocated_mask, rhs) : false;
Utilities/pugixml.cpp:		return dn ? impl::set_value_convert(dn->value, dn->header, impl::xml_memory_page_value_allocated_mask, rhs) : false;
Utilities/pugixml.cpp:		return dn ? impl::set_value_bool(dn->value, dn->header, impl::xml_memory_page_value_allocated_mask, rhs) : false;
Utilities/pugixml.cpp:		return dn ? impl::set_value_integer<unsigned long long>(dn->value, dn->header, impl::xml_memory_page_value_allocated_mask, rhs, rhs < 0) : false;
Utilities/pugixml.cpp:		return dn ? impl::set_value_integer<unsigned long long>(dn->value, dn->header, impl::xml_memory_page_value_allocated_mask, rhs, false) : false;
Utilities/pugixml.cpp:	// Workarounds for (non-standard) iterator category detection for older versions (MSVC7/IC8 and earlier)
Utilities/pugixml.cpp:	// Workarounds for (non-standard) iterator category detection
Utilities/pugixml.cpp:		assert(ln->parent == rn->parent);
Utilities/pugixml.cpp:		if (!ln->parent) return ln < rn;
Utilities/pugixml.cpp:			ln = ln->parent;
Utilities/pugixml.cpp:			rn = rn->parent;
Utilities/pugixml.cpp:		while (ln->parent != rn->parent)
Utilities/pugixml.cpp:			ln = ln->parent;
Utilities/pugixml.cpp:			rn = rn->parent;
Utilities/pugixml.cpp:			// need to make dummy on-heap copy
Utilities/pugixml.cpp:		// $$ we can't use offsetof(T, name) because T is non-POD, so we just allocate additional length characters
Utilities/pugixml.cpp:			// need to make dummy on-heap copy
Utilities/pugixml.cpp:				if (type == node_element && n->name && strequal(n->name, _data.nodetest))
Utilities/pugixml.cpp:				if (type == node_pi && n->name && strequal(n->name, _data.nodetest))
Utilities/pugixml.cpp:				if (type == node_element && n->name && starts_with(n->name, _data.nodetest))
Utilities/pugixml.cpp:				for (xml_attribute_struct* a = n->first_attribute; a; a = a->next_attribute)
Utilities/pugixml.cpp:				for (xml_node_struct* c = n->first_child; c; c = c->next_sibling)
Utilities/pugixml.cpp:				xml_node_struct* cur = n->first_child;
Utilities/pugixml.cpp:				for (xml_node_struct* c = n->next_sibling; c; c = c->next_sibling)
Utilities/pugixml.cpp:				for (xml_node_struct* c = n->prev_sibling_c; c->next_sibling; c = c->prev_sibling_c)
Utilities/pugixml.cpp:				xml_node_struct* cur = n->parent;
Utilities/pugixml.cpp:				if (n->parent)
Utilities/pugixml.cpp:					step_push(ns, n->parent, alloc);
Utilities/pugixml.cpp:			// allocate on-heap for large concats
Utilities/pugixml.cpp:			for (xpath_ast_node* n = _right; n; n = n->_next, ++pos) buffer[pos] = n->eval_string(c, swapped_stack);
Utilities/pugixml.cpp:				for (xpath_ast_node* n = _right; n; n = n->_next)
Utilities/pugixml.cpp:					if (!n->is_posinv_expr()) return false;
Utilities/pugixml.cpp:			for (xpath_ast_node* n = _right; n; n = n->_next)
Utilities/pugixml.cpp:				assert(n->_type == ast_predicate);
Utilities/pugixml.cpp:				if (n->_test != predicate_posinv)
Utilities/pugixml.cpp:				if (n->rettype() != xpath_type_node_set)
Utilities/pugixml.cpp:				else n->set_right(pred);
Utilities/pugixml.cpp:			// else clause moved outside of if because of bogus warning 'control may reach end of non-void function being inlined' in gcc 4.0.1
Utilities/pugixml.cpp:						if (n->rettype() != xpath_type_node_set)
Utilities/pugixml.hpp:		// Non-copyable semantics
Utilities/pugixml.hpp:		// Load document from buffer, using the buffer for in-place parsing (the buffer is modified and used for storage of document data).
Utilities/pugixml.hpp:		// Load document from buffer, using the buffer for in-place parsing (the buffer is modified and used for storage of document data).
Utilities/pugixml.hpp:		// Non-copyable semantics
Utilities/pugixml.hpp:		// Non-copyable semantics
Utilities/pugixml.hpp:		// We define non-constant iterator to be the same as constant iterator so that various generic algorithms (i.e. boost foreach) work
Utilities/pugixml.hpp:	// Workarounds for (non-standard) iterator category detection for older versions (MSVC7/IC8 and earlier)
Utilities/pugixml.hpp:	// Workarounds for (non-standard) iterator category detection
VReduction/VReduction.cpp:		// Push n-1 identical particles into particle bank
VReduction/VReduction.cpp:		for ( int i = 0 ; i < n-1 ; i++ )
